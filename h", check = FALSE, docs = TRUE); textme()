[1;33mâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[1;33mmodified: R/antigen.garnish_io.R
[1;33mâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[1;35m@ antigen.garnish_io.R:191 @[1m[38;5;146m garnish_summary <- function(dt){[0m
           transcripts = dt[ensembl_transcript_id %>% unique] %>% nrow[m
           ))[m

     }) %>% data.table::rbindlist[m

     dtn <- merge(dtn, dtnv, by = "sample_id", all = TRUE)[m
 }[m


 return(dtn)[m
}[m



## ---- garnish_variants[m
#' Process VCF variants and return a data table for epitope prediction.[m
#'[m
#' Process paired tumor-normal VCF variants annotated with [SnpEff](http://snpeff.sourceforge.net/) for neoepitope prediction using `garnish_predictions`. VCFs from matched samples can be optionally intersected to select only variants present across input files.[m
#'[m
#' @param vcfs Paths to VFC files to import.[m
#' @param intersect Logical. Return only the intersection of variants in multiple `vcfs` with identical sample names? Intersection performed on `SnpEff` annotations. [1;32m{+`vcf`+}[m
#'[m
#' @return A data table with one unique SnpEff variant annotation per row, including:[m
#' * **sample_id**: sample identifier constructed from input \code{.bam} file names[m
#' * **se**: SnpEff annotation[m
#' * **effect_type**: SnpEff effect type[m
#' * **ensembl_transcript_id**: transcript effected[m
#' * **ensembl_gene_id**: gene effected[m
#' * **protein_change**: protein change in [HGVS](http://varnomen.hgvs.org/recommendations/DNA/) format[m
[1;35m@ antigen.garnish_io.R:256 @[1m[38;5;146m garnish_variants <- function(vcfs, intersect = TRUE){[0m
                     stringr::str_extract_all("[^ ]+\\.bam") %>%[m
                     unlist %>%[m
                     unique %>%[m
                     basename %>%[m
                     sort %>%[m
                     paste(collapse = "_") %>%[m
                     stringr::str_replace("\\.bam", "")[m
 # extract vcf type[m
     vcf_type <- vcf@meta %>%
       unlist %>%
       [1;31m[-stringr::str_extract(stringr::regex("Strelka|Mutect",-][m[1;32m{+stringr::str_extract(stringr::regex("(Strelka)|(Mutect)|(VarScan)|(samtools mpileup)|(somaticsniper)|(freebayes)|(virmidr)",+}[m
         ignore_case = TRUE)) %>%
       stats::na.omit %>%
                unlist %>%
       data.table::first
     if (vcf_type %>% length == 0) vcf_type <- "other"[m

 # return a data table of variants[m

   vdt <- vcf@fix %>% data.table::as.data.table[m

 # check that VCF is SnpEff-annotated[m

[1;35m@ antigen.garnish_io.R:299 @[1m[38;5;146m garnish_variants <- function(vcfs, intersect = TRUE){[0m

   # filter out NA[m
   vdt %<>% .[!ensembl_transcript_id %>% is.na &[m
              !cDNA_change %>% is.na][m

   return(vdt)[m
   })[m

   [1;32m{+rename_vcf_fields <- function(dt1, dt2) {+}[m

[1;32m{+       # a function to rename VCF INFO and+}[m
[1;32m{+        # FORMAT fields for merging+}[m

[1;32m{+      for (common_col in c("INFO", "FORMAT")){+}[m

[1;32m{+          if (common_col %chin% (dt %>% names))+}[m
[1;32m{+            dt %>%+}[m
[1;32m{+              data.table::setnames(common_col,+}[m
[1;32m{+                paste0(common_col, "_", dt[, vcf_type[1]]))+}[m
[1;32m{+          if (common_col %chin% (dt2 %>% names))+}[m
[1;32m{+            dt2 %>%+}[m
[1;32m{+              data.table::setnames(common_col,+}[m
[1;32m{+                paste0(common_col, "_", dt2[, vcf_type[1]]))+}[m
[1;32m{+        }+}[m
[1;32m{+    }+}[m


 merge_vcf <- function(dt, dt2){[m

   # a function to intersect annotated variants
     [1;32m{+#+}[m across VCFs using SnpEff

     sdt <- merge(dt, dt2[, .SD,[m
                .SDcols = c("INFO",[m
                            "FORMAT",[m
                            "ensembl_transcript_id",[m
                            "cDNA_change")],[m
                by = c("ensembl_transcript_id",[m
                       "cDNA_change"))

     [1;31m[-%>%-][m
[1;31m[-        .[,-][m[1;32m{+sdt[,+}[m vcf_type := "intersect"]
        return(sdt)[m

 }[m

 union_vcf <- function(dt, dt2){[m

   # a function to take the union of annotated variants
     [1;32m{+#+}[m across VCFs using SnpEff

     [1;31m[-sdt-][m[1;32m{+rename_vcf_fields(dt, dt2)+}[m
[1;32m{+      browser()+}[m
[1;32m{+      mdt+}[m <- merge(dt, dt2[, .SD,
                .SDcols = [1;31m[-c("INFO",-][m
[1;31m[-                           "FORMAT",-][m[1;32m{+c(dt2 %>% names %include% "^INFO",+}[m
[1;32m{+                             dt2 %>% names %include% "^FORMAT",+}[m
                            "ensembl_transcript_id",[m
                            "cDNA_change")],[m
[1;31m[-                all = TRUE,-][m
                 by = c("ensembl_transcript_id",[m
                         "cDNA_change"))

     [1;32m{+overlaps <- mdt[, paste0(ensembl_transcript_id,+}[m
[1;32m{+                               cDNA_change)+}[m %>%
                       [1;31m[-.[,-][m[1;32m{+unique]+}[m

[1;32m{+      sdt <- rbindlist(list(+}[m
[1;32m{+            mdt,+}[m
[1;32m{+            dt[!paste0(ensembl_transcript_id, cDNA_change) %chin%+}[m
[1;32m{+              overlaps],+}[m
[1;32m{+            dt2[!paste0(ensembl_transcript_id, cDNA_change) %chin%+}[m
[1;32m{+              overlaps]+}[m
[1;32m{+              ), use.names = TRUE, fill = TRUE)+}[m


[1;32m{+      sdt[,+}[m vcf_type := "union"]
          return(sdt)[m

 }[m

     sample_ids <- lapply(ivfdtl, function(dt){[m
                   dt$sample_id %>% unique[m
                     }) [1;32m{+%>% unique+}[m

   # return an intersected data table of variants[m

     sdt <- [1;31m[-parallel::mclapply(sample_ids,-][m[1;32m{+lapply(sample_ids, ##### TODO+}[m
                               function(sn){[m

       # find data tables with matching sample names[m

         sdt <- lapply(ivfdtl, function(dt){[m

            dt[, sample_id %>% .[1]] == sn[m

[1;33mâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[1;33mmodified: tests/testthat/test-garnish_variants_intersection.R
[1;33mâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[1;35m@ test-garnish_variants_intersection.R:16 @[1m[38;5;146m testthat::test_that("garnish_variants intersection", {[0m
   "antigen.garnish_example_strelka.vcf" %>%[m
     utils::download.file(paste0("http://get.rech.io/", .), .)[m

 # run test[m
   dto_i <- garnish_variants(c("antigen.garnish_example_mutect2.vcf",[m
                    "antigen.garnish_example_strelka.vcf"))[m

 testthat::expect_equal(dto_i %>% length, 23)[m
 testthat::expect_equal(dto_i %>% nrow, [1;31m[-64)-][m[1;32m{+32)+}[m

 # run test[m
 dto_ni <- garnish_variants(c("antigen.garnish_example_mutect2.vcf",[m
                    "antigen.garnish_example_strelka.vcf"),[m
           intersect = FALSE)[m

 testthat::expect_equal(dto_ni %>% length, [1;31m[-23)-][m[1;32m{+25)+}[m
 testthat::expect_equal(dto_ni %>% nrow, [1;31m[-118)-][m[1;32m{+145)+}[m

   })[m
