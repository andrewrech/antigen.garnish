---
title: "antigen.garnish: ensemble neoepitope prediction from DNA variants in R."
author: "Lee P. Richman, Andrew J. Rech"
output: html_document
---

```{r setup, include=FALSE}
library(knitr)
library(antigen.garnish)
library(data.table)
library(magrittr)
library(ggplot2)
knitr::opts_chunk$set(cache = TRUE, dpi=360, eval = FALSE, error = FALSE, warning = FALSE, message = FALSE, comment = "#", cache.comments = FALSE, fig.align = "center")
```

# `antigen.garnish` vignette

Welcome to the `antigen.garnish` introductory usage vignette. This vignette covers basic workflow for each type of input and highlights useful output parameters for further study. An example analysis is provided using supplementary data from [*Lukza et al. 2017*](https://www.ncbi.nlm.nih.gov/pubmed/29132144). For requirements, installation instructions, workflow examples, and more information on the MHC binding prediction algorithms used by the package, please see the [README](https://github.com/andrewrech/`antigen.garnish`).

## Introduction

`antigen.garnish` is an software package written in R that performs ensemble neoantigen prediction and quality analysis from SNVs, indels, and fusions. `antigen.garnish` uses seven published algorithms to predict MHC binding affinity, classifies neoepitopes by biological characteristics (see `?garnish_summary`), and applies a [neoantigen fitness model](https://www.ncbi.nlm.nih.gov/pubmed/29132144). Supported input formats include VCFs, [JAFFA](https://github.com/Oshlack/JAFFA/wiki) output, or simple tables of transcripts or peptides level data. `antigen.garnish` does not perform variant calling or MHC haplotyping. We recommend following the [GATK](https://software.broadinstitute.org/gatk/best-practices/workflow?id=11146) best practices to call somatic variants and using at least two variant callers. The package has been most thoroughly tested with output from [MuTect2](https://software.broadinstitute.org/gatk/documentation/tooldocs/3.8-0/org_broadinstitute_gatk_tools_walkers_cancer_m2_MuTect2.php) and [Strelka2](https://github.com/Illumina/strelka). Variants can be [intersected](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5394620/) using the `garnish_predictions` function. For gene fusion analysis from RNAseq, see `?garnish_jaffa`.

## `antigen.garnish` input

### VCF input

The `garnish_variants` functions parses `vcf` or `vcf.gz` files using the [vcfR](https://cran.r-project.org/web/packages/vcfR/index.html) package. Sample names are determined by searching `vcf` headers for `BAM` file names. Files with identical sample names will be intersected by default. We recommend intersecting variant calls to [improve sensitivity](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5394620/) and minimize false positive variant calls. See `?garnish_variants` for more information. If multiple `vcf` files exist per sample, files should be [concatenated](http://vcftools.sourceforge.net/perl_module.html#vcf-concat).

`vcf` input must be annotated with [SnpEff](http://snpeff.sourceforge.net/). Annotations are used to identify which variants to keep. SNV and indel variants that will produce a change in predicted peptide sequence for the associated transcript will be returned in an output data table. Non-coding variants will be dropped. Transcript metadata and sequences are queried from [biomaRt](https://bioconductor.org/packages/release/bioc/html/biomaRt.html).


```{r getdt, include = FALSE}

dt <- "antigen.garnish_example.vcf" %T>%
      utils::download.file("http://get.rech.io/antigen.garnish_example.vcf", .) %>%

  # run test
    garnish_variants

file.remove("antigen.garnish_example.vcf")

```

```{r vcf, eval = FALSE}

# prepare vcf input from all vcfs in working directory

vcfs <- list.files(pattern = "\\.vcf(\\.gz)?$")
dt <- garnish_variants(vcfs)
```

```{r vcf2}
str(dt)
```

`garnish_variants` returns a data table with one annotated variant per row that includes the following columns:

  - **sample_id**: sample identifier constructed from input \code{.bam} file names
  - **effect_type**: SnpEff effect type
  - **ensembl_transcript_id**: transcript effected
  - **protein_change**: protein change in [HGVS](http://varnomen.hgvs.org/recommendations/DNA/) format

### Gene fusions input

To evaluate novel peptides generated across the breakpoint of a predicted gene fusion, `garnish_jaffa` parses results from [JAFFA](https://github.com/Oshlack/JAFFA/wiki) run on RNAseq data. This function takes the fasta output of fusion reads and the output table of fusion predictions. Only fusions that are predicted by JAFFA to align across exons, are in-frame, and are classified as *Medium* or *High* confidence are analyzed. See `garnish_jaffa` for more information.

```{r jaffahide, include = FALSE}

path <- "antigen.garnish_jaffa_results.csv" %T>%
     utils::download.file("http://get.rech.io/antigen.garnish_jaffa_results.csv", .)
    fasta_path <- "antigen.garnish_jaffa_results.fasta" %T>%
      utils::download.file("http://get.rech.io/antigen.garnish_jaffa_results.fasta", .)

# get predictions
  
dt <- antigen.garnish::garnish_jaffa(path, db = "GRCm38", fasta_path)

```
```{r jaffa, eval = FALSE}

dt <- garnish_jaffa(path = "jaffa_results.csv",
                    db = "GRCm38",
                    fasta_path = "jaffa_results.fasta")

```
```{r jaffashow}
# lets take a peek
str(dt)
```

### Table input

##### TODO link example table

Peptide level direct input, either a data.table or data.frame in R or a file path. `mutant_index` indicates the position of the mutated amino acid.

```{r otherpep, echo = FALSE}

data.table::data.table(sample_id = "sample_1",
                       pep_mut = c("MTEYKLVVVDAGGVGKSALTIQLIQNHFV", "SIINFEKLANTIGENGARNISHFDT"),
                        mutant_index = c(15, "all"), MHC = c("HLA-A*02:01",
                                                   "H-2-Kb H-2-IAb"))

```

Transcript level input, requires Ensembl Transcript ID without version number appended:

```{r othert, echo = FALSE}

data.table::data.table(sample_id = "sample_1",
                       ensembl_transcript_id = c("ENST00000311936", "ENSMUST00000032399"),
                        cDNA_change = c("c.718T>A","c.35G>T"), MHC = c("HLA-DRB1*11:07", "H-2-Kb H-2-IAb"))

```

## Neoepitpe prediction

MHC types must be provided for each sample for MHC binding affinity prediction.

To see proper formatting and supported MHC alleles:

```{r mhclist}
mhcdt <- list_mhc()

# class I mouse alleles supported and their syntax

mhcdt[species == "mouse" & class == "I"] %>% print

```

If MHC types are not already included in the table passed to `garnish_predictions` with tables containing MHC alleles already, they can be manually added. Multiple MHC alleles for a single sample should be entered as a space separated string, e.g. "H-2Kb H-2-Db H-2-IAb".

```{r addmhc}

# add the MHC 
dt[, MHC := "H-2Kb H-2-Db H-2-IAb"]

str(dt)

```


```{r getpdt, include = FALSE}

pdt <- data.table::fread("http://get.rech.io/antigen.garnish_example_output.txt") %>%
  .[, fitness_score := 4.2]

```

`garnish_predictions` will generate all possible novel 8-15mers derived from  input variants. Peptides are filtered against the wild-type human or mouse peptidomes from UniProt. Peptides derived from variants that match a wildtype sequence are removed from further analysis. By default, the NCBI BLAST [CLI](https://blast.ncbi.nlm.nih.gov/Blast.cgi) is then used to query for wild-type "near matches" for frameshift and fusion proteins, as well as against the [IEDB](http://www.iedb.org/database_export_v3.php). 

##### TODO clarify IEDB matching

MHC prediction algorithms used by `antigen.garnish` are [mhcflurry](https://github.com/hammerlab/mhcflurry), [mhcnuggets](https://github.com/KarchinLab/mhcnuggets), [netMHC](http://www.cbs.dtu.dk/services/NetMHC/), [netMHCII](http://www.cbs.dtu.dk/services/NetMHCII/), [netMHCpan](http://www.cbs.dtu.dk/services/NetMHCpan/) and [netMHCIIpan](http://www.cbs.dtu.dk/services/NetMHCIIpan/i). Peptides are passed to all possible prediction algorithms for all supported permutations of alleles and peptide lengths.

The returned binding affinities are then averaged together to generate the `Consensus_scores`. A 95% confidence interval based on the t-distribution is provided when at least 3 unique predicitons are available. An immune fitness model adapted from [*Lukza et al. 2017*](https://www.ncbi.nlm.nih.gov/pubmed/29132144) is then applied by default.

```{r predict, eval  = FALSE}

# run prediction tools and fitness model

pdt <- garnish_predictions(dt)

```

```{r showpredict}
dim(pdt)

# large table so lets just look at the columns
names(pdt)
```

The resulting table includes:

 * **pep_type**: type of peptide
 * **pep_mut**: mutant peptide sequence
 * **_net**: netMHC prediction tool output
 * **mhcflurry_**: mhcflurry prediction tool output
 * **mhcnuggets_**: mhcnuggets prediction tool output
 * **Consensus\_scores**: Average value of MHC binding affinity from all prediction tools that contributed output. 95\% confidence intervals are given by `Upper_CI`, `Lower_CI`.
 * **DAI**: Differential agretopicty index, see `garnish_summary` for an explanation of DAI.

Fitness model results:

 * **ResidueChangeClass**: Amino acid change class, eg hydrophobic to non-hydrophobic.
 * **A**: Component of the fitness model. Differential MHC affinity of mutant and closest wt peptide, equivalent to DAI if available, otherwise uses BLAST_A.
 * **R**: TCR recognition probability, determined by comparison to known epitopes in the IEDB and amino acid properties.
 * **fitness_score**: Product of A and R. The peptide with the highest value per sample is the dominant neoepitope.

## `antigen.garnish` output

Sample-level summary analysis of `garnish_predictions` results is performed by the `garnish_summary` function. This allows for a quick analysis of overall neoepitope burden by neoepitope class, MHC class, and type of variant.

```{r summ}

sdt <- garnish_summary(pdt)

print(sdt)

```

Simple column graphs including overall neoepitope burden, breakdown by affinity, and top 3 scores (see `?garnish_summary`) can be produced and saved to the working directory.

```{r plot}

garnish_plot(pdt)

list.files(pattern = "antigen.garnish.*\\.pdf$")

```

Here are some example plots:

![](http://get.rech.io/ag_plots_example.png)

## Analysis

##### TODO Continue with data ...

In this example, we will import the data from [*Lukza et al. 2017*](https://www.ncbi.nlm.nih.gov/pubmed/29132144), modified to conform to the necessary input format of antigen.garnish. We will then summarize and plot the data, and show the concordance of fitness_score and their reported "NeoantigenRecognitionPotential".

```{r readin, eval = FALSE}

dt <- data.table::fread("http://get.rech.io/Lukza_input.txt")

head(dt)

# now we need to subset the data into the minimum columns required for prediction and rename them appropriately

dti <- dt[, .SD, .SDcols = c("Sample", "MT.Peptide", "WT.Peptide", "HLA")] %>%
          data.table::setnames(c("Sample", "MT.Peptide", "HLA"),
                               c("sample_id", "pep_mut", "MHC"))

# lets take a random sample of 1,000 rows to make this smaller
set.seed(42)

dts <- dti[sample(1:nrow(dti), size = 1000)]

# function to identify mutant index from this input

get_mi <- function(a,b){

  a %<>% strsplit(split = "") %>% unlist
  b %<>% strsplit(split = "") %>% unlist

  return(which(a != b))

}

dts[, mutant_index := get_mi(pep_mut, WT.Peptide), by = 1:nrow(dts)]

##### remove below

# fix MHC syntax to conform with antigen.garnish requirements
dts[, MHC := MHC %>% stringr::str_replace_all("^|\\ ", " HLA-") %>%
              stringr::str_replace("^\\ ", "")] %>%
      .[, MHC := paste(
        stringr::str_extract_all(MHC, pattern = "HLA-[ABCE]") %>% unlist,
        "*",
        stringr::str_extract_all(MHC, pattern = "(?<=(HLA-[ABCE]))[0-9]{2}") %>% unlist,
        ":",
        stringr::str_extract_all(MHC, pattern = "[0-9]{2}$") %>% unlist,
        sep = "") %>% paste(collapse = " "),
        by = 1:nrow(dts)]

dto <- garnish_predictions(dts)

fit_dt <- data.table::fread("http://get.rech.io/Lukza_output.txt")

##### TODO: show fitness vs NRP, ratio and histogram

```

```{r cleanup, include = FALSE}

list.files(pattern = "antigen.garnish.*\\.pdf$") %>% file.remove

c("antigen.garnish_jaffa_results.csv", "antigen.garnish_jaffa_results.fasta") %>% file.remove

```

```{r session}
sessionInfo()
```
